#!/usr/bin/env python3
import os
import gi
gi.require_version("Gtk", "3.0")
gi.require_version('Wnck', '3.0')
gi.require_version('Keybinder', '3.0')
from gi.repository import Gtk, Wnck, Gdk, Gio, Keybinder
import subprocess
import pyperclip
import pyautogui
import time
import ast


filepath = os.path.dirname(os.path.abspath(__file__))
prefspath = os.path.join(
    os.environ["HOME"], ".config", "quickchar"
)
os.makedirs(prefspath, exist_ok=True)


css_data = """
.instruction {
  color: grey;
  font-style: italic;
}
.button {
  border-radius: 0px;
}
.entry {
  min-width: 30px;
  font-weight: bold;
  color: blue;
}
"""


def create_charlists():
    chardata = []
    file = os.path.join(filepath, "chardata")
    return [l.strip().split() for l in open(file).readlines()]


class Window(Gtk.Window):

    def __init__(self):

        Gtk.Window.__init__(self)
        # window defs
        self.set_decorated(False)
        self.set_keep_above(True)
        self.set_title("Charlookup")
        self.set_position(Gtk.WindowPosition.CENTER_ALWAYS)
        self.connect("key-press-event", self.get_key)
        self.set_skip_taskbar_hint(True)
        # let's initiate a few things
        self.surpass_signal = False
        self.currfamily = None
        self.tail = None
        self.currpage = 0
        self.pages = []
        self.previously_used = os.path.join(
            prefspath, "previously_used",
        )
        self.previous_ison = None
        self.pu_data = self.read_previous()
        # gui stuff
        self.maingrid = Gtk.Grid()
        self.add(self.maingrid)
        self.provider = Gtk.CssProvider.new()
        self.provider.load_from_data(css_data.encode())
        self.searchentry = Gtk.Entry()
        self.maingrid.attach(self.searchentry, 0, 0, 1, 1)
        self.instructionlabel = Gtk.Label(label="\tType a character\t")
        self.set_style(self.instructionlabel, "instruction")
        self.maingrid.attach(self.instructionlabel, 1, 0, 1, 1)
        # set style
        self.set_style(self.searchentry, "entry")
        self.searchentry.set_width_chars(1)
        self.searchentry.set_alignment(xalign=0.5)
        # ...
        self.searchentry.connect("changed", self.search_new)
        self.show_all()

    def read_previous(self):
        try:
            return ast.literal_eval(
                open(self.previously_used).read()
            )
        except FileNotFoundError:
            return []

    def set_style(self, widget, style):
        widget_context = widget.get_style_context()
        widget_context.add_class(style)
        Gtk.StyleContext.add_provider(
            widget_context, self.provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION,
        )

    def search_new(self, entry):
        self.instructionlabel.destroy()
        currtext = entry.get_text()
        if any([len(currtext) > 1, self.surpass_signal is False]):
            search = currtext[-1]
            entry.set_text(search)
            self.set_row(search)
            self.surpass_signal = True
        else:
            self.surpass_signal = False

    def get_activewin(self):
        winlist = []
        winnames = []
        wm_classes = []
        # only on startup, else from file (wrapper script)
        self.screendata = Wnck.Screen.get_default()
        self.screendata.force_update()
        wlist = [
            w for w in self.screendata.get_windows_stacked()
        ]
        for w in wlist:
            if w.get_window_type() == Wnck.WindowType.NORMAL:
                winlist.append(w.get_xid())
                winnames.append(w.get_name())
                wm_classes.append(w.get_class_group_name())
        try:
            index = winnames.index("Charlookup") - 1
            subj = winlist[index]
            subj_wmclass = wm_classes[index]
            return [subj, subj_wmclass]
        except IndexError:
            pass

    def get_key(self, button, val, string=None):
        key = Gdk.keyval_name(val.keyval)
        if key == "Escape":
            self.wrapitup()
        elif all([key in ["Return", "KP_Enter", "Enter"], string]):
            self.paste(button, string)

    def makebutton(self, s, lastpicked, page=None):
        button = Gtk.Button(label=s)
        self.set_style(button, "button")
        button.connect("key-press-event", self.get_key, s)
        button.connect("pressed", self.paste, s)
        if lastpicked:
            self.set_style(button, Gtk.STYLE_CLASS_SUGGESTED_ACTION)
            if page:
                self.currpage = page - 1
        return button

    def maketail(self):
        # tail
        buttontail = Gtk.HBox()
        # browse buttons
        right_icon = Gtk.Image.new_from_icon_name(
            "go-next-symbolic", Gtk.IconSize.BUTTON
        )
        self.browseright = Gtk.Button()
        self.browseright.set_image(right_icon)
        self.browseright.set_relief(Gtk.ReliefStyle.NONE)
        left_icon = Gtk.Image.new_from_icon_name(
            "go-previous-symbolic", Gtk.IconSize.BUTTON
        )
        self.browseleft = Gtk.Button()
        self.browseleft.set_image(left_icon)
        self.browseleft.set_relief(Gtk.ReliefStyle.NONE)
        buttontail.pack_start(Gtk.Label(label="  "), False, False, 0)
        buttontail.pack_start(self.browseleft, False, False, 0)
        buttontail.pack_start(self.browseright, False, False, 0)
        self.browseright.connect("clicked", self.go_nextpage, "right")
        self.browseleft.connect("clicked", self.go_nextpage, "left")
        return buttontail

    def go_nextpage(self, button, direction):
        if direction == "right":
            n_pages = len(self.pages)
            self.currpage = self.currpage + 1
            self.currpage = self.currpage if self.currpage < n_pages else None
        elif direction == "left":
            self.currpage = self.currpage - 1
            self.currpage = self.currpage if self.currpage >= 0 else None
        if self.currpage is not None:
            self.currfamily.set_visible_child_name(self.pages[self.currpage])
            self.manage_browsbuttons_active()

    def manage_browsbuttons_active(self):
        if self.currpage >= len(self.pages) - 1:
            set_browseright = False
        else:
            set_browseright = True
        if self.currpage <= 0:
            set_browseleft = False
        else:
            set_browseleft = True
        self.browseright.set_sensitive(set_browseright)
        self.browseleft.set_sensitive(set_browseleft)

    def set_row(self, searchval):
        row = []
        self.previous_ison = "Page1"
        try:
            self.maingrid.remove(self.currfamily)
        except (TypeError, AttributeError):
            pass
        try:
            self.tail.destroy()
        except (TypeError, AttributeError):
            pass
        for r in chardata:
            if r[0] == searchval:
                self.currfamily = Gtk.HBox()
                row = r[1:]
                break
        # get last used
        last_used = None
        for item in self.pu_data:
            if item[0] == searchval:
                last_used = item[1]
                break
        # create widget
        if len(row) > 10:
            self.currpage = 0
            self.pages = []
            # create stack
            self.currfamily = Gtk.Stack()
            self.currfamily.set_transition_type(
                Gtk.StackTransitionType.SLIDE_LEFT_RIGHT
            )
            self.currfamily.set_transition_duration(500)
            self.currfamily.set_vexpand(True)
            self.currfamily.set_hexpand(True)
            n = 1
            rownumber = 1
            newbox = Gtk.HBox()
            for s in row:
                button = self.makebutton(s, s == last_used, rownumber)
                newbox.pack_start(button, False, False, 0)
                if n == 10:
                    pagename = "Page" + str(rownumber)
                    self.pages.append(pagename)
                    self.currfamily.add_named(newbox, pagename)
                    n = 0
                    rownumber = rownumber + 1
                    newbox = Gtk.HBox()
                n = n + 1
            # last row
            if n > 2:
                pagename = "Page" + str(rownumber)
                self.pages.append(pagename)
                self.currfamily.add_named(newbox, pagename)
                n = 1
            # tail
            self.tail = self.maketail()
            # throw it on the window
            self.maingrid.attach(self.currfamily, 1, 0, 1, 1)
            self.maingrid.attach(self.tail, 100, 0, 1, 1)
            self.manage_browsbuttons_active()
            self.maingrid.show_all()
            self.currfamily.set_visible_child_name(self.pages[self.currpage])
        else:
            self.currfamily = Gtk.HBox()
            for s in row:
                button = self.makebutton(s, s == last_used)
                self.currfamily.pack_start(button, False, False, 0)
            self.maingrid.attach(self.currfamily, 1, 0, 1, 1)
        self.maingrid.show_all()
        self.resize(10, 10)

    def wrapitup(self):
        self.destroy()

    def paste(self, button, char, *args):
        windata = self.get_activewin()
        if windata:
            win = windata[0]
            wmclass = windata[1]
            pyperclip.copy(char)
            subprocess.call(["wmctrl", "-ia", str(win)])
            time.sleep(0.05)
            # set exception to the rule
            if wmclass == "Tilix":
                pyautogui.hotkey('shift', 'ctrl', 'v')
            # the default Ctrl-v
            else:
                # subprocess.Popen(["xdotool", "key", "Control_L+v"])
                # ^^^ slightly slower :(
                pyautogui.hotkey("ctrl", "v")
            # update last-used
            family = self.searchentry.get_text()
            index = None
            for item in self.pu_data:
                if item[0] == family:
                    index = self.pu_data.index(item)
                    break
            newdata = [family, char]
            if index is not None:
                self.pu_data[index] = newdata
            else:
                self.pu_data.append(newdata)
            open(self.previously_used, "wt").write(str(self.pu_data))
        self.destroy()


def checkonwin():
    screendata = Wnck.Screen.get_default()
    screendata.force_update()
    for w in screendata.get_windows_stacked():
        if w.get_name() == "Charlookup":
            return w


def toggle_win(arg):
    # create or destroy the window
    win = checkonwin()
    if not win:
        Window()
        subprocess.Popen(os.path.join(filepath, "raise.sh"))
    else:
        subprocess.Popen(["wmctrl", "-ic", str(win.get_xid())])


def startup_stuff():
    # start "deamon"
    Keybinder.init()
    if Keybinder.supported():
        Keybinder.bind("<Super><Alt>c", toggle_win)
    Gtk.main()


chardata = create_charlists()
startup_stuff()
